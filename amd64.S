/* primitives and native-code routines on AMD64

# Why a mainstream assembler?

Some Forthers have criticised the decision by Ting (for his
version of eForth) and JonesForth to use a mainstream
assembler rather than a Forth assembler, but the popularity of
these systems seems to support the decision to use a
mainstream assembler.

Here I use a mainstream assembler for the assembly code,
because Bernd Paysan's Forth assembler for AMD64 has very
unconventional syntax, and I don't want to put all the things
necessary to load that assembler into fforth.

For the Forth part I use a meta-compiler.

*/
	
/* register usage: we use Forth-symbolic register names instead of
	Intel/AMD register names */

#define rp  rsp
#define sp  rbx
#define tos rax
#define ctos al
#define ltos eax
#define wa  rax
	
/* Data stack representation

	The data stack grows towards lower addresses.  sp points to
	the second item, the top item is in TOS */

#define sec (%sp)
#define third cell(%sp)
#define fourth 2*cell(%sp)
	
/* temporary registers: rcx rdx rdi rsi
   unused: r8-r15; so porting to IA-32 should be easy
*/

	/* header fields */
#define cell 8
#define cfa (-1*cell)
#define does (-2*cell)
	
	.text
	/* run-time routines for word classes; these are used when the
	word is EXECUTEd or DEFERred; when a word is executed as part
	of a colon definition, the code generated by COMPILE, is used
	instead; run-time routines get the body address in register wa.
	*/
	/* colon definitions are EXECUTEd by calling them, no docol
	needed */

dovar:	/* variables and the like */
	leaq -cell(%sp),%sp
	movq %tos, sec
	movq %wa, %tos
	ret
dovar_e:

docon:	/* constants */
	leaq -cell(%sp),%sp
	movq %tos, sec
	movq (%wa), %tos
	ret
docon_e:

dodefer: /* deferred words */
	movq (%wa), %wa
	jmp *cfa(%wa)
dodefer_e:	

dodoes:	/* does>-defined words */
	leaq -cell(%sp),%sp
	movq %tos, sec
	movq %wa, %tos
	movq does(%wa),%wa
	jmp *cfa(%wa)
dodoes_e:
	
	/* primitives */
execute:
	movq %tos, %wa
	movq sec, %tos
	leaq cell(%sp),%sp
	call *cfa(%wa)
execute_e:	

semis:
	ret
semis_e:
	
plus:	addq sec, %tos
	leaq cell(%sp),%sp
plus_e:	
	ret

fetch:	movq (%tos), %tos
fetch_e:
	ret

cfetch:	 movzbq (%tos), %tos
cfetch_e:
	ret

store:	movq sec, %rdx
	movq %tos, (%rdx)
	movq third, %tos
	leaq 2*cell(%sp),%sp
store_e:
	ret

cstore:	movq sec, %rdx
	movb %ctos, (%rdx)
	movq third, %tos
	leaq 2*cell(%sp),%sp
cstore_e:
	ret

lstore:	movq sec, %rdx
	movl %ltos, (%rdx)
	movq third, %tos
	leaq 2*cell(%sp),%sp
lstore_e:
	ret


move:	movq third,%rsi
	movq sec,%rdi
	movq %tos, %rcx
	movq fourth,%tos
	leaq 3*cell(%sp),%sp	
	rep movsb
move_e:	ret

dup:	leaq -cell(%sp),%sp
	movq %tos, sec
dup_e:	ret

drop:	movq sec,%tos
	leaq cell(%sp),%sp
drop_e:	ret
	
lit:	leaq -cell(%sp),%sp
	movq %tos, sec
	mov $12345678900, %tos
lit_e:	

branch:	jmp .+1000000
branch_e:	
	
zbranch: 
	testq %tos,%tos
	movq sec,%tos
	leaq cell(%sp),%sp
	jz .+1000000
zbranch_e:

call:   call .+1000000
call_e:	
